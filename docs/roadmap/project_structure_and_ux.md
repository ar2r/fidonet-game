# Организация проекта для масштабируемых квестов и лучшего UX

## 1. Цель

Сделать кодовую базу такой, чтобы:
- новый квест добавлялся как контент, а не как правка в 5+ местах;
- UI оставался тонким (только отображение), а игровая логика жила в движке;
- поведение проверялось автотестами на уровне сценариев, а не только отдельных функций.

---

## 2. Что сейчас тормозит развитие

По текущему коду:

- `src/engine/commandParser.js` одновременно парсит команды, меняет состояние, двигает квесты, выдает награды и запускает async-эффекты.
- `src/App.jsx` содержит часть квестовой логики (например, completion для `configure_tmail`/`configure_golded`), то есть квесты размазаны между engine и UI.
- `src/components/TerminalWindow.jsx` занимается и UI, и оркестрацией времени/гейм-правил.
- `src/engine/quests.js` хранит квесты в виде простого списка, но без формальных шагов/условий/триггеров.
- `src/engine/events.js` не встроен в основной цикл (фактически “мертвый” модуль).
- Глобальные keydown-листенеры в окнах повышают риск конфликтов ввода при росте числа экранов.

Итог: чем больше квестов, тем выше связность и риск регрессий.

---

## 3. Целевая архитектура

### 3.1 Принцип слоев

1. `content` (данные): квесты, диалоги, тексты, баланс.
2. `domain/engine` (правила): команды, события, триггеры, эффекты, прогрессия.
3. `features/ui` (интерфейс): рендер окон, ввод, отображение состояния.

UI не должен знать “как именно проходится квест”, только отправлять события типа `file.saved`, `command.executed`, `program.opened`.

### 3.2 Квест как декларативный сценарий

Каждый квест описывается структурой с шагами и условиями.

Пример контракта:

```js
{
  id: "configure_tmail",
  act: 2,
  title: "Настройка T-Mail",
  prerequisites: ["download_software"],
  steps: [
    { id: "open_editor", type: "event", event: "program.opened", program: "t-mail" },
    { id: "save_valid_config", type: "event", event: "file.saved", path: "C:\\FIDO\\T-MAIL.CTL", validator: "tmail.valid" }
  ],
  rewards: [{ type: "skill", key: "software", delta: 2 }],
  nextQuest: "configure_golded"
}
```

Что дает:
- добавление квеста = новый файл контента;
- меньше условных блоков в `commandParser`;
- автоматическая валидация структуры квеста тестами.

### 3.3 Event-driven core

Ввести единый поток доменных событий:
- `command.executed`
- `bbs.connected`
- `download.completed`
- `file.saved`
- `time.advanced`
- `virus.infected` / `virus.cleaned`

Quest Engine подписывается на события и решает:
- какие шаги закрыты;
- какие награды выдать;
- когда открыть следующий квест/акт.

### 3.4 Команды как реестр хендлеров

Вместо одного большого `if/else`:
- реестр команд по режимам (`IDLE`, `BBS_MENU`, `BBS_FILES`, ...);
- каждый handler возвращает доменные эффекты (patch state + output + events);
- async-эффекты (симуляция загрузки/дозвона) идут через единый scheduler/side-effect слой.

---

## 4. Рекомендуемая структура каталогов

```text
src/
  app/
    store/
  domain/
    command/
      handlers/
      registry.js
    quests/
      engine.js
      schema.js
      validators.js
    events/
      bus.js
      types.js
    time/
    world/
  content/
    quests/
      act1/
      act2/
    dialogs/
    manuals/
  features/
    desktop/
    terminal/
    programs/
      tmail/
      golded/
  shared/
    ui/
    lib/
```

---

## 5. Как должен добавляться новый квест

1. Создать файл в `src/content/quests/actX/...`.
2. Описать `steps`, `prerequisites`, `rewards`, `nextQuest`.
3. При необходимости добавить новый validator (например, `golded.valid`).
4. Добавить/переиспользовать доменное событие (если текущих не хватает).
5. Написать сценарный тест “happy path + fail path”.

Цель: без правок в `App.jsx` и без ручного `triggerQuest(...)` в каждой команде.

---

## 6. UX-улучшения (приоритетно)

### P0 (быстрые победы)

- Встроенный журнал квеста (цель, шаги, что уже сделано, что дальше).
- Команда `HINT` с контекстной подсказкой по активному шагу.
- “Понятные ошибки ввода”: предлагать ближайшую команду при опечатке.
- Явный фидбек после действия: `+предмет`, `+навык`, `время +N минут`, `стат -N`.
- Единый фокус ввода: только активное окно принимает клавиатуру.

### P1 (после стабилизации ядра)

- Guided onboarding на старте (чеклист первых 3-4 действий).
- История диалогов/лог SysOp в отдельном окне.
- Ускорение долгих симуляций (кнопка “пропустить анимацию” для повторных попыток).
- Настраиваемая доступность: размер шрифта терминала, скорость текста, уменьшение мерцания CRT.

---

## 7. Качество и тесты

Нужно добавить 3 уровня тестирования:

1. Contract tests для квестов:
   - уникальность `id`;
   - валидные ссылки `nextQuest`/`prerequisites`;
   - корректные типы наград и шагов.
2. Scenario tests:
   - прохождение акта end-to-end через события;
   - негативные ветки (неправильный конфиг, отсутствие файла и т.д.).
3. UI integration tests:
   - отображение активного шага квеста;
   - корректный ввод в активном окне;
   - ключевые onboarding-потоки.

---

## 8. Пошаговый план миграции

### Шаг 1. Стабилизировать границы (без смены поведения)
- Вынести completion квестов из `App.jsx` в domain-сервис.
- Добавить event bus и пробрасывать события из текущих обработчиков.
- Сохранить текущие команды/тексты как есть.

### Шаг 2. Декларативные квесты
- Ввести schema + validator.
- Перенести текущие квесты Act 1/Act 2 в `content/quests`.
- Убрать ручные проверки `if (active === "...")` из UI и parser.

### Шаг 3. Командный движок
- Разбить `commandParser` на handlers по режимам.
- Добавить реестр команд и общие утилиты ответа/эффектов.

### Шаг 4. UX слой
- Добавить Quest Journal + Hint + улучшенные сообщения ошибок.
- Ввести единый Input Manager для окон.

### Шаг 5. Масштабирование контента
- Шаблон нового квеста.
- Чеклист “definition of done” для контентных PR.
- Минимум 1 сценарный тест на каждый новый квест.

---

## 9. Что делать первым (конкретный старт)

1. Вынести логику прогрессии квестов из `src/App.jsx` в `domain/quests`.
2. Добавить доменные события `file.saved`, `download.completed`, `bbs.connected`.
3. Завести `schema` для квеста и перевести текущий `quests.js` на новый формат.
4. Разбить `commandParser` на mode-handlers, сохранив текущее поведение.
5. Добавить базовый Quest Journal в UI (можно как отдельное окно).

Это даст максимальный эффект по скорости добавления новых квестов уже на ближайших итерациях.
